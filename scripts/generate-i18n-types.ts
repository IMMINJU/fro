/**
 * i18n Type Generator
 * Generates TypeScript types from translation JSON files
 * Run: npm run i18n:types
 */

import fs from 'fs'
import path from 'path'

const MESSAGES_DIR = path.join(process.cwd(), 'messages')
const OUTPUT_FILE = path.join(process.cwd(), 'src/types/i18n.generated.ts')

type JsonValue = string | number | boolean | null | JsonObject | JsonArray
interface JsonObject {
  [key: string]: JsonValue
}
type JsonArray = JsonValue[]

/**
 * Flatten nested object keys into dot notation
 * { a: { b: 'value' } } => ['a.b']
 */
function flattenKeys(obj: JsonObject, prefix = ''): string[] {
  const keys: string[] = []

  for (const [key, value] of Object.entries(obj)) {
    const fullKey = prefix ? `${prefix}.${key}` : key

    if (value && typeof value === 'object' && !Array.isArray(value)) {
      keys.push(...flattenKeys(value as JsonObject, fullKey))
    } else {
      keys.push(fullKey)
    }
  }

  return keys
}

/**
 * Generate TypeScript union type from keys
 */
function generateTypeDefinition(namespace: string, keys: string[]): string {
  const typeName = `${namespace.charAt(0).toUpperCase()}${namespace.slice(1)}Keys`
  const unionType = keys.map(k => `  | '${k}'`).join('\n')

  return `export type ${typeName} =\n${unionType}\n`
}

/**
 * Generate all types from messages directory
 */
function generateTypes() {
  console.log('üîß Generating i18n types...\n')

  const namespaces = ['common', 'cloud']
  const sharedNamespaces = ['validation', 'navigation']

  let output = `/**
 * Auto-generated i18n types
 * DO NOT EDIT MANUALLY
 * Generated by: scripts/generate-i18n-types.ts
 */

`

  // Generate types for main namespaces
  for (const namespace of namespaces) {
    const filePath = path.join(MESSAGES_DIR, namespace, 'en.json')

    if (!fs.existsSync(filePath)) {
      console.warn(`‚ö†Ô∏è  Warning: ${filePath} not found, skipping...`)
      continue
    }

    const content = fs.readFileSync(filePath, 'utf-8')
    const json = JSON.parse(content) as JsonObject
    const keys = flattenKeys(json)

    output += generateTypeDefinition(namespace, keys)
    output += '\n'

    console.log(`‚úÖ ${namespace}: ${keys.length} keys`)
  }

  // Generate types for shared namespaces
  for (const namespace of sharedNamespaces) {
    const filePath = path.join(MESSAGES_DIR, 'shared', namespace, 'en.json')

    if (!fs.existsSync(filePath)) {
      console.warn(`‚ö†Ô∏è  Warning: ${filePath} not found, skipping...`)
      continue
    }

    const content = fs.readFileSync(filePath, 'utf-8')
    const json = JSON.parse(content) as JsonObject
    const keys = flattenKeys(json)

    output += generateTypeDefinition(namespace, keys)
    output += '\n'

    console.log(`‚úÖ ${namespace}: ${keys.length} keys`)
  }

  // Add translation function type
  output += `/**
 * Type-safe translation function
 * Usage: const t = useTranslations<CommonKeys>('common')
 */
export type TranslationFunction<T extends string> = (key: T) => string
`

  // Write to file
  const outputDir = path.dirname(OUTPUT_FILE)
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true })
  }

  fs.writeFileSync(OUTPUT_FILE, output, 'utf-8')
  console.log(`\n‚ú® Types generated: ${OUTPUT_FILE}`)
}

// Run
try {
  generateTypes()
} catch (error) {
  console.error('‚ùå Error generating types:', error)
  process.exit(1)
}
